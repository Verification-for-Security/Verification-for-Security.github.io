**Verification for Security (XM_0099)** 
    [*Klaus v. Gleissenthall*](https://gleissen.github.io/)

[Back](index.html)

Project Ideas
============================================================== 

- Easy: Extend our verifier with pointers and prove the correctness of a pointer manipulating program (say, a linked-list implementation).
- Easy: Extend our verifier with Bitvector types. Implement a crypto-algorithm (AES, SHA) and prove its correctness.
- Easy: Build a larger verified application with our verifier and add a runtime with webassembly (you can use [this](https://www.wasm.builders/gunjan_0307/compiling-javascript-to-wasm-34lk) as a starting point).
- Easy: add automation to our verifier by implementing [this paper](https://users.soe.ucsc.edu/~cormac/papers/fme01.pdf). This is an easier algorithm than the one discussed in class.
- Easy: Implement IFC type system for nano, and write a secure application. 
- Easy/Medium: Implement a program synthesis tool. Take a look at [this blog post](https://barghouthi.github.io/2017/04/24/synthesis-primer/) to get you started. Can you think of a class of programs where sythesis is particularly useful?
- Easy/Medium: Add Horn clause inference via predicate abstraction to the verifier, as discussed in class.
- Easy/Medium: Implement this [type system](https://people.eecs.berkeley.edu/~necula/Papers/ccured_toplas.pdf) for memory safety.
- Easy/Medium: Implement a different type system for memory safety: see [this](https://borretti.me/article/type-systems-memory-safety) for inspiration.
- Easy/Medium: Extend our verifier to make it more usable. Whenever Z3 produces a counterexample use [QuickCheck](https://hackage.haskell.org/package/QuickCheck) to test if the counterexample is reachable. If yes, the program is incorrect. Else, the invariant has to be refined.
- Easy/Medium: Add a “decreases” annotation to the verifier, like in [Dafny](http://dafny.org/latest/DafnyRef/DafnyRef#sec-decreases-clause). This can be used to prove termination. Use can use [this](https://ethz.ch/content/dam/ethz/special-interest/infk/chair-program-method/pm/documents/Education/Theses/Patrick_Gruntz_BA_report.pdf) as starting point.
- Easy/Medium: Build a VCGen based verifier for LLVM IR, e.g., using [this library](https://hackage.haskell.org/package/llvm-hs).
- Easy/Medium: Reimplement [this paper](https://files.sri.inf.ethz.ch/website/papers/sigcomm20-netdice.pdf) for probabilistic network verification.
- Easy/Medium: Reimplement [this paper](https://www.cs.princeton.edu/~dpw/papers/minesweeper-sigcomm17.pdf) for SMT based network verification.
- Medium: Add a more advanced memory model to our verifier. To start, take a look at [this paper](https://link.springer.com/chapter/10.1007/978-3-540-93900-9_24) or [this paper](https://arxiv.org/pdf/1703.00053.pdf).
- Medium: Build a VCGen based verifier for Verilog hardware.
- Medium: Build a type system checking for memory safety for LLVM, building on [this paper](https://people.eecs.berkeley.edu/~necula/Papers/ccured_toplas.pdf).
- Medium: Build an automated verifier e.g., using [liquid fixpoint](https://github.com/ucsd-progsys/liquid-fixpoint), that proves bounds checks for arrays in  LLVM IR.
- Medium: Implement a staged verifier for C code; see [this paper](https://dl.acm.org/doi/pdf/10.1145/3009837.3009867) for inspiration.
- Medium: Typecheck OS code using IFC, see [this paper](http://www.scs.stanford.edu/histar/).
- Medium: Build an IFC language and type-system for Verilog, and use it to prove timing-chache side-channel freedom. See also [this paper](https://www.cs.cornell.edu/andru/papers/asplos15/asplos15.pdf).
- Medium: Build an automated verifier (e.g., using liquid fixpoint) that verifies leakage freedom for software by building a product program  see [this paper](https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/almeida) for inspiration.
- Medium: Build a VCGen based verifier for BlueSpec Verilog.
- Medium: Implement invariant generation using non-linear solving, following [this paper](https://link.springer.com/chapter/10.1007/978-3-540-45069-6_39).
- Medium: Implement [liquid types checking](https://arxiv.org/pdf/2010.07763.pdf).
- Medium: We can use arrays to reason about concurrent programs that are run with arbitrary many threads. Each array element is used to encode the local state of one of the threads. See e.g., [this paper](https://dl.acm.org/doi/10.1145/3009837.3009893). Implement and verify a challenging concurrent algorithm.
- Medium: Implement an IFC type system for assembly to prove timing-channel freedom.
- Medium: Build a verifier that can prove absence of spectre gadgets.
- Medium: Build a type-system to protect against a different spectre variant or row-hammer.
- Medium/Hard: Implement a verifier based on relational Hoare logic (medium), or probabilistic Hoare logic (hard), see these [lecture notes](https://software.imdea.org/~gbarthe/__introrelver.pdf).
- Medium/Hard: Implement an alternative approach to Horn clause solving e.g., from [this paper](https://arxiv.org/pdf/1610.06768.pdf) or [this paper](https://link.springer.com/chapter/10.1007/978-3-319-08867-9_55).
- Medium/Hard: Implement a VCGen-based verifier for P4 networking code.
- Medium/Hard: Implement ideas from [this paper](https://link.springer.com/chapter/10.1007/978-3-642-14295-6_7) to prove program termination or non-termination via ranking functions.
- Medium/Hard: Implement a verifier for Rust, following [this paper](https://arxiv.org/pdf/2002.09002.pdf).
- Medium/Hard: Define a semantics and correctness notion for [Hertzbleed](https://www.hertzbleed.com).
- Medium/Hard: Implement a type checker for masking implementations against power side-channels, see [this paper](https://eprint.iacr.org/2015/506.pdf).
- Medium/Hard: Implement a checker for differential privacy, see [this paper](https://dl.acm.org/doi/pdf/10.1145/3158146) or [this paper](https://www.cse.psu.edu/~dbz5017/pub/popl17.pdf).
- Medium/Hard: Extend our verifier with [refinement proofs](https://dl.acm.org/doi/pdf/10.1145/3492545), for security or concurrency. What would be a good way to represent these proofs at the program level?
- Medium/Hard: Implement a verifier for neural networks: see these [lecture notes](https://verifieddeeplearning.com/nnv_book.pdf).
- Medium/Hard: Implement [this paper](https://arxiv.org/pdf/1303.2489.pdf) to build an automated verifier that can deal with more complicated data-structures like linked-lists.
- Medium/Hard: Networks can have side-channels and leak via inter-packet timing. Design a security notion for networks based on differential privacy, see [this paper](https://www.cis.upenn.edu/~sga001/papers/ifs-ccs21.pdf) and [this paper](https://arxiv.org/pdf/1905.02383.pdf). 
- Hard: Implement an IFC type systen for [Spinal HDL](https://github.com/SpinalHDL/SpinalHDL) and use it to check security properties of [this processor](https://github.com/proteus-core/prospect/tree/master).
- Hard: Build an IFC language for software that proves leakage freedom, under a specific hardware contract: see [this paper](https://gleissen.github.io/papers/ccs2023.pdf).
- Hard: Build an IFC system that verifies leakage model for Verilog hardware, see [this paper](https://gleissen.github.io/papers/ccs2023.pdf) and [this paper](https://www.usenix.org/system/files/usenixsecurity23-daniel.pdf).
- Hard Build a program semantics for Rowhammer and define a notion of security.
- Hard: Verify parts of Rust’s foreign function interface, see [this paper](https://goto.ucsd.edu/~rjhala/hotos-ffi.pdf).
- Hard: Implement a type-checker for probabilistic proofs of cryptographic protocols, see [this paper](https://dl.acm.org/doi/pdf/10.1145/3571223).
- Hard: Implement a verifier for quantum algorithms, see e.g., [this paper](https://dl.acm.org/doi/10.1145/3582016.3582039).
- Hard: Use Farkas’ lemma, see [this paper](https://link.springer.com/chapter/10.1007/978-3-540-45069-6_39) to automatically infer invariants for quantum programs.



<!-- Markdeep: --><style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style><script src="markdeep.min.js" charset="utf-8"></script><script src="https://morgan3d.github.io/markdeep/latest/markdeep.min.js" charset="utf-8"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>