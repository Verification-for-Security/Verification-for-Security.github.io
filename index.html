**Verification for Security (XM_0099)** 
    [*Klaus v. Gleissenthall*](https://gleissen.github.io/)

About
============================================================== 

This course focuses on formal verification with an eye on security. For the
first part of the course, we will cover the basics of formal verification
through lectures. We'll start from zero, but move fast. The purpose of this part
of the course is to give you the necessary background to understand and
implement program verification tools. In fact, we'll build both an SMT solver
and a fully functioning program verifier, similar to Amazon's
[Dafny](http://dafny.org/), from the ground up. In the second part of the
course, you'll get to apply that knowledge to build a verification project of
your own. The purpose of the course is to give you a deep understanding of
program verification and prepare you for research in the area.

Lectures:
    - Tuesday, 11:00--12:45 in NU-3A57 and Wednesday 15:30--17:15 in MF-A415. 
    - Check [rooster](https://rooster.vu.nl/schedule) for more detailed scheduling info.

Staff:
    - **Lectures**: Klaus v. Gleissenthall 
    - **Practicals**: Robin Webbers

Practical Session:
    - Friday 11:00 - 12:45 in NU-3A57.

Grading
==============================================================     

The grade will consist of assignment grades (25%), project grade (25%) and final
exam grade (50%). The exam must be passed with a grade >= 5.5. Each of the
practical assignments must be passed with a grade >= 4.0. There will be a resit
exam on January 9, 2024, but there will be no resit for the practical
assignments or project.


Component                     |  Percentage
------------------------------|-------------------
 Assignments  | 25%
 Project      | 25%
 Final Exam   | 50%



Syllabus and Calendar
==============================================================

Tue Sep 5 2023: Intro & Propositional Logic
    - In this lecture we'll go over course admin.
    - We'll also start with the material.
    - To reason about programs, we need to know logic, the language of computation.
    - We'll start with the simplest one: propositional logic.
    - [Slides](slides/lecture1.pdf) 
Wed Sep 6 2023: Normal Forms & DPLL
    - To use propositional logic for reasoning about programs, we need to be able to solve questions about formulas alorithmically.
    - In this lecture, we cover the DPLL algorithm that can check whether a propositional formula is satisfiable.
    - [Slides](slides/lecture2.pdf) 
Sun Sep 10 2023: Deadline: Assignment due (2 pts)
    - Intro to Haskell & Monads due 
    - Also see this [tutorial](https://docs.google.com/document/d/1On06ZVBocHEOzlIQFq1MrQzwOjeKE-MyDE7eNPkyiDo/edit?usp=sharing) we wrote about monads.
Tue Sep 12 2023: First-order Logic
    - We now know how to solve questions about propositional logic, but the logic is too limited to encode many interesting questions about programs.
    - In this lecture, we'll look at a *way* more expressive logic: first order logic (FOL).
    - In fact, we'll see that FOL is *too* expressive! 
    - It's no longer possible to answer questions algorithmically in an efficient way, as most interesting problems are undecidable. 
    - [Slides](slides/lecture3.pdf) 
Wed Sep 13 2023: First-order Theories
    - Propositional logic was not expressive enough, FOL was too expressive.
    - In this lectures we'll talk about the Goldilocks of logics: first-order theories.
    - First-order theories allow us to encode many interesting questions about programs while still maintaining decidability.
    - We'll learn about satisfiability modulo theories (or SMT) which underlies most modern tools for verification, symbolic execution and bug finding.
    - [Slides](slides/lecture4.pdf) 
Sun Sep 17 2023: Deadline: Assignment 1a (2 pt)
Tue Sep 19 2023: Nano & Hoare Logic
    - Now that we've learned about the right logic to reason about programs, we can start to look at actual programs!
    - We'll start by defining an imperative language, called Nano, and giving it formal semantics.
    - Next, we need to think about when these programs are correct. For this, we'll take a look at Hoare logic.
    - [Slides](slides/lecture5.pdf) 
Wed Sep 20 2023: Hoare Logic & VCGen 
    - Hoare logic is great, as it lets us talk about the correctness of programs.
    - But so far, we have to do proofs manually by constructing a derivation in Hoare logic.
    - Instead, we'll now partially automate proofs by creating a set of verification conditions--SMT formulas whose validity lets us deduce whether the program is correct.
    - We can then send these to an SMT solver.
    - Now, all we have to do is write loop invariants, and we can check their correctness automatically. 
    - [Slides](slides/lecture4.pdf) 
Sun Sep 24 2023: Deadline: Monads & DPLL & SMT (6 pt)   
Tue Sep 26 2023: VCs for Functions and Pointer
Wed Sep 27 2023: Horn Clauses
Sun Oct 1 2023: Deadline: Assignment 2: VCGen (10 pt)
Tue Oct 3 2023: Solving Horn Clauses
Wed Oct 4 2023: Information Flow Control
Wed Oct 4 2023: Deadline: Project Proposal
Tue Oct 10 2023: IFC & Side-Channels
Wed Oct 11 2023: Project Progress Reports
Wed Oct 18 2023: Project Progress Reports
Tue Oct 24 2023: Final Exam
Sun Oct 28 2023: Deadline: Final Project

Assignments
==============================================================    

## Overview 

Assignments          |  Points  | Due Date
---------------------|----------|-------------------
 0: Haskell & Monads | 2 pt     | 10 Sep 2023
 1a: Formal Proofs   | 2 pt     | 17 Sep 2023
 1b: DPLL & SMT      | 6 pt     | 24 Sep 2023
 2 : VCGen           | 10 pt    | 01 Oct 2023

 - All assignments will be written in [Haskell](https://www.haskell.org/). 
 - You may not be familiar with Haskell yet, but we'll do our best to catch you up.
 - Check out this awesome [tutorial](http://learnyouahaskell.com/chapters) to get you started.
 - Monads have proven to be one of the toughest topics to understand. We wrote this [tutorial](https://docs.google.com/document/d/1On06ZVBocHEOzlIQFq1MrQzwOjeKE-MyDE7eNPkyiDo/edit?usp=sharing) to help.
 - Haskell is not an arbitrary choice, it's the core language for this type of research.
 - One of the learning goals of this course is to get you aquainted with this type of programming.
 - Knowing functional programming well will make you a better programmer, both in Haskell and other languages.
 - On this note, you may be interested to read why PL researchers [love Haskell so much](https://www.quora.com/Why-do-computer-scientists-like-Haskell-so-much).

 ## Details

 - Assignment 1: Haskell and Monads
    - Once you're done, please fill out [this form](https://docs.google.com/forms/d/1IQzEiNOiue__Ca5qLbcAMewfOYfr7DLH5hc0UY0fCVU/edit) to give us feedback on the assignment.
 - Assignment 2: DPLL and SMT
 - Assignment 3: Hoare Logic and VCGen

Projects
==============================================================

- Use the tools you learned in class! This is where you get to show us what you learned. 
- The project needs to be written in Haskell; build your own DSL (like Nano); use existing Haskell libraries.
- Start small. Build a small core language and implement the most important functionality. Then scale up.
- The projects will be done in groups of 2, as before.
- First you'll have to submit a 1 page proposal. 
- Next, you'll implement the project and write a report of up to three pages. 
- What worked? what didn’t? what was hard?
- Evaluate your project on a set of benchmarks.
- You should have a Readme.md file telling us how to run your project, and add documentation throughout the code. 
- Make sure it compiles---we can’t grade it otherwise.
- You can pick an idea below or come up with your own. If you pick your own idea, you need to get an okay from us.
- We reward ambition. Projects might turn into research that could get published. This has happened with [similar courses in the past](https://cseweb.ucsd.edu/~dstefan/cse227-spring22/#halloffame).
- If you pick a more difficult topic you can get a (very) good grade even if you don’t fully achieve your intended result (but take a serious step towards the goal). 
- If you pick a simple topic, your prototype should be fully functional and you should evaluate it well. 
- Only ambitious projects (Medium or Hard) can earn grades 9 or 10.

## Project Proposal 
Your proposal should briefly address the following questions (less than one page):

- What are you trying to do? Did you explain the problem?
- How is the problem you are addressing done today? What are the limits?
- Citations from previous works are encouraged and don't count towards your page limit.
- What is new and why do you think you will be successful?
- Are there security applications of the project?
- Why is this important?
- What are the risks?

These questions have been adopted from the [Heilmeier Catechism](https://www.darpa.mil/work-with-us/heilmeier-catechism).

You can upload the proposal via [Canvas](https://canvas.vu.nl/courses/71804).

## Project Ideas

See [this page](projects.html) for a list of project ideas.

## Hall of Fame: Best Projects
TBD

<!-- Markdeep: --><style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style><script src="markdeep.min.js" charset="utf-8"></script><script src="https://morgan3d.github.io/markdeep/latest/markdeep.min.js" charset="utf-8"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>