**Verification for Security (XM_0099)** 
    [*Klaus v. Gleissenthall*](https://gleissen.github.io/)

About
============================================================== 

This course focuses on formal verification with an eye on security. For the
first part of the course, we will cover the basics of formal verification
through lectures. We'll start from zero, but move fast. The purpose of this part
of the course is to give you the necessary backbround to understand and
implement program verification tools. In fact, we'll build both an SMT solver
and a fully functioning program verifier, similar to Amazon's
[Dafny](http://dafny.org/), from the ground up. In the second part of the
course, you'll get to apply that knowledge to build a verification project of
your own. The purpose of the course is to give you a deep understanding of
program verification and prepare you for research in the area.

Lectures:
    - Tuesday, 11:00--12:45 in NU-3A57 and Wednesday 15:30--17:15 in MF-A415. 
    - Check [rooster](https://rooster.vu.nl/schedule) for more detailed scheduling info.

Staff:
    - **Lectures**: Klaus v. Gleissenthall 
    - **Practicals**: Robin Webbers

Practical Session:
    - Friday 11:00 - 12:45 in NU-3A57.

Grading
==============================================================     

The grade will consist of assignment grades (25%), project grade (25%) and final
exam grade (50%). The exam must be passed with a grade >= 5.5. Each of the
practical assignments must be passed with a grade >= 4.0. There will be a resit
exam on January 9, 2024, but there will be no resit for the practical
assignments or project.



Syllabus and Calendar
==============================================================

Tue Sep 5 2023: Intro & Propositional Logic
    - Slides 
Wed Sep 6 2023: Normal Forms & DPLL
Sun Sep 10 2023: Deadline: Assignment due (2 pts)
    - Intro to Haskell & Monads due 
    - github repo
    - Also see this [tutorial](https://docs.google.com/document/d/1On06ZVBocHEOzlIQFq1MrQzwOjeKE-MyDE7eNPkyiDo/edit?usp=sharing) on monads.
Tue Sep 12 2023: First-order Logic
Wed Sep 13 2023: First-order Theories
Sun Sep 17 2023: Deadline: Assignment 1a (2 pt)
Tue Sep 19 2023: Nano & Hoare Logic
Wed Sep 20 2023: Hoare Logic & VCGen 
Sun Sep 24 2023: Monads & DPLL & SMT (6 pt)   
Tue Sep 26 2023: VCs for Functions and Pointer
Wed Sep 27 2023: Horn Clauses
Sun Oct 1 2023: Deadline: Assignment 2: VCGen (10 pt)
Tue Oct 3 2023: Solving Horn Clauses
Wed Oct 4 2023: Information Flow Control
Wed Oct 4 2023: Deadline: Project Proposal
Tue Oct 10 2023: IFC & Side-Channels
Wed Oct 11 2023: Project Progress Reports
Wed Oct 18 2023: Project Progress Reports
Tue Oct 24 2023: Final Exam
Sun Oct 28 2023: Deadline: Final Project

Assignments
==============================================================     
- Assignment 1: Haskell and Monads
- Assignment 2: DPLL and SMT
- Assignment 3: Hoare Logic and VCGen

Projects
==============================================================

- Use the tools you learned in class! This is where you get to show us what you learned. 
- The project needs to be written in Haskell; build your own DSL (like Nano); use existing Haskell libraries.
- Start small. Build a small core language and implement the most important functionality. Then scale up.
- The projects will be done in groups of 2, as before.
- First you'll have to submit a 1 page proposal. 
- Next, you'll omplement the project and write a report of up to three pages. 
- What worked? what didn’t? what was hard?
- Evaluate your project on a set of benchmarks.
- You should have a Readme file telling us how to run your project, and add documentation throughout the code. 
- Make sure it compiles–we can’t grade it otherwise.
- You can pick an idea below or come up with your own. If you pick your own idea, you need to get an okay from us.
- We reward ambition. Projects might turn into research that could get published. This has happened with [similar courses in the past](https://cseweb.ucsd.edu/~dstefan/cse227-spring22/#halloffame).
- If you pick a more difficult topic you can get a (very) good grade even if you don’t fully achieve your intended result (but take a serious step towards the goal). 
- If you pick a simple topic, your prototype should be fully functional and you should evaluate it well. 
- Only ambitious projects (Medium or Hard) can earn grades 9 or 10.

## Project Proposal 
Your proposal should briefly address the following questions (less than one page):

- What are you trying to do? Did you explain the problem?
- How is the problem you are addressing done today? What are the limits?
- Citations from previous works are encouraged and don't count towards your page limit.
- What is new and why do you think you will be successful?
- Are there security applications of the project?
- Why is this important?
- What are the risks?

You can upload the proposal via Canvas.

## Project Ideas

- Easy: Extend our verifier with pointers and prove the correctness of a pointer manipulating program (say, a linked-list implementation).
- Easy: Extend our verifier with Bitvector types. Implement a crypto-algorithm (AES, SHA) and prove its correctness.
- Easy: Build a larger verified application with our verifier and add a runtime with webassembly (you can use [this](https://www.wasm.builders/gunjan_0307/compiling-javascript-to-wasm-34lk) as a starting point).
- Easy/Medium: Add Horn clause inference via predicate abstraction to the verifier, as discussed in class.
- Easy: add automation to our verifier by implementing [this paper](https://users.soe.ucsc.edu/~cormac/papers/fme01.pdf). This is an easier algorithm than the one discussed in class.
- Easy: Implement IFC type system for nano, and write a secure application. 
- Easy/Medium: Implement this [type system](https://people.eecs.berkeley.edu/~necula/Papers/ccured_toplas.pdf) for memory safety.
- Easy/Medium: Implement a different type system for memory safety: see [this](https://borretti.me/article/type-systems-memory-safety) for inspiration.
- Easy/Medium: Extend our verifier to make it more usable. Whenever Z3 produces a counterexample use [QuickCheck](https://hackage.haskell.org/package/QuickCheck) to test if the counterexample is reachable. If yes, the program is incorrect. Else, the invariant has to be refined.
- Easy/Medium: Add a “decreases” annotation to the verifier, like in [Dafny](http://dafny.org/latest/DafnyRef/DafnyRef#sec-decreases-clause). This can be used to prove termination. Use can use [this](https://ethz.ch/content/dam/ethz/special-interest/infk/chair-program-method/pm/documents/Education/Theses/Patrick_Gruntz_BA_report.pdf) as starting point.
- Easy/Medium: Build a VCGen based verifier for LLVM IR, e.g., using [this library](https://hackage.haskell.org/package/llvm-hs).
- Medium: Build a VCGen based verifier for Verilog hardware.
- Medium: Build a type system checking for memory safety for LLVM, building on [this paper](https://people.eecs.berkeley.edu/~necula/Papers/ccured_toplas.pdf).
- Medium/Hard: Implement ideas from [this paper](https://link.springer.com/chapter/10.1007/978-3-642-14295-6_7) to prove program termination or non-termination via ranking functions.
- Medium: Build an automated verifier e.g., using [liquid fixpoint](https://github.com/ucsd-progsys/liquid-fixpoint), that proves bounds checks for arrays in  LLVM IR.
- Medium/Hard: Implement a VCGEN-based verifier for P4 networking code.
- Medium: Build an IFC language and type-system for Verilog, and use it to prove timing-chache side-channel freedom.
- Medium: Build an automated verifier (e.g., using liquid fixpoint) that verifies leakage freedom for software by building a product program  see [this paper](https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/almeida) for inspiration.
- Medium/Hard: Implement an alternative approach to Horn clause solving e.g., from [this paper](https://arxiv.org/pdf/1610.06768.pdf) or [this paper](https://link.springer.com/chapter/10.1007/978-3-319-08867-9_55).
- Medium: Implement a staged verifier for C code; see [this paper](https://dl.acm.org/doi/pdf/10.1145/3009837.3009867) for inspiration.
- Medium: Typecheck OS code using IFC, see [this paper](http://www.scs.stanford.edu/histar/).
- Hard: Build an IFC language for software that proves leakage freedom, under a specific hardware contract: see [this paper](https://gleissen.github.io/papers/ccs2023.pdf).
- Hard: Build an IFC system that verifies leakage model for Verilog hardware, see [this paper](https://gleissen.github.io/papers/ccs2023.pdf) and [this paper](https://www.usenix.org/system/files/usenixsecurity23-daniel.pdf).
- Hard Build a program semantics for Rowhammer and define a notion of security.
- Medium: Build a type-system to protect against a different spectre variant or row-hammer.
- Medium/Hard: Implement a verifier for Rust, following https://arxiv.org/pdf/2002.09002.pdf.
- Hard: Verify parts of Rust’s foreign function interface: https://goto.ucsd.edu/~rjhala/hotos-ffi.pdf.
- Medium: Implement invariant generation using non-linear solving, following https://link.springer.com/chapter/10.1007/978-3-540-45069-6_39.
- Medium: Implement liquid types checking https://arxiv.org/pdf/2010.07763.pdf.
- Medium: We can use arrays to reason about concurrent programs that are run with arbitrary many threads. Each array element is used to encode the local state of one of the threads. Implement and verify a challenging concurrent algorithm.
- Medium: Implement an IFC type system for assembly to prove timing-channel freedom.
- Medium/Hard: Implement a verifier based on relational Hoare logic, or probabilistic Hoare logic (see https://software.imdea.org/~gbarthe/__introrelver.pdf).
- Medium: Build a verifier that can prove absence of spectre gadgets.
- Hard: Implement a type-checker for probabilistic proofs of cryptographic protocols, see https://dl.acm.org/doi/pdf/10.1145/3571223 .
- Medium/Hard: Define a semantics and correctness notion for https://www.hertzbleed.com
- Medium/Hard: Implement a type checker for masking implementations against power side-channels: https://eprint.iacr.org/2015/506.pdf
- Medium/Hard: Implement a checker for differential privacy, see  https://dl.acm.org/doi/pdf/10.1145/3158146 or https://www.cse.psu.edu/~dbz5017/pub/popl17.pdf
- Medium/Hard: Extend our verifier with refinement proofs (for security or concurrency). What would be a good way to represent these proofs at the program level? https://dl.acm.org/doi/pdf/10.1145/3492545
- Medium/Hard: Implement a verifier for neural networks: https://verifieddeeplearning.com/nnv_book.pdf
- Medium/Hard: Implement https://arxiv.org/pdf/1303.2489.pdf to build an automated verifier that can deal with more complicated data-structures like linked-lists.
- Hard: Implement a verifier for quantum algorithms, see: https://dl.acm.org/doi/10.1145/3582016.3582039
- Hard: Use Farkas’ lemma (see https://link.springer.com/chapter/10.1007/978-3-540-45069-6_39) to automatically infer invariants for quantum programs.


## Hall of Fame: Best Projects
TBD

<!-- Markdeep: --><style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style><script src="markdeep.min.js" charset="utf-8"></script><script src="https://morgan3d.github.io/markdeep/latest/markdeep.min.js" charset="utf-8"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>